%info
Simple performance profiling that reports time spent in each function.

Uses perf record followed by perf report to list functions sorted by
overhead. Outputs RESULT-PERF-<symbol>@<pid> for each function above the
PERF_MIN threshold.

For more advanced classification-based profiling, see the perf-class module.

Variables:
  PERF_OPT   - Extra options for perf record (default: empty)
  PERF_TIME  - Recording duration in seconds (default: 4)
  PERF_EVENT - Hardware event to record (default: cycles)
  PERF_MIN   - Minimum overhead percentage to report (default: 1)
  PERF_PATH  - Path to perf binary (default: perf)

Usage:
  %import@dut perf-functions PERF_TIME=5 PERF_MIN=2

%config


%variables
PERF_OPT=
PERF_TIME?=4
PERF_EVENT=cycles
PERF_MIN=1

%late_variables
PERF_PATH?=perf

%script sudo=true autokill=false
trap : INT
sh script.sh

%file script.sh
echo "Launching perf record..."
trap : INT
${PERF_PATH} record -r 80 -F 1000 -a -g $PERF_OPT -o perf.data -e $PERF_EVENT sleep $PERF_TIME
${PERF_PATH} report -s overhead -F symbol,overhead,pid --call-graph none -t "," $PERF_OPT --no-children --percentage relative | grep -v '^#' > perf.list
cat perf.list | while read line; do
    sym=$(echo $line | cut -d',' -f1 | xargs)
    pc=$(echo $line | cut -d',' -f2 | xargs | grep -oE '[0-9.]*' )
    roundpc=$(echo $pc | grep -oE '[0-9]*' | head -n 1)
    pid=$(echo $line | cut -d',' -f3 | xargs)
    if [ $(echo "$pc < $PERF_MIN" | bc) -eq 1 ] ; then break; fi
    if [ "$sym" != "" ] ; then
        echo "RESULT-PERF-$(echo $sym | sed 's/[^0-9a-zA-Z_~]*//g' )@$(echo $pid | sed 's/[^0-9a-zA-Z_~]*//g' ) $pc"
    fi
done
