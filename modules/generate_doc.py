#!/usr/bin/env python3
"""Generate per-module RST documentation for the npf-docs wiki.

Reads all .npf files in the modules/ directory, extracts their %info sections,
skips deprecated modules, and writes one .rst file per module into the
``modules/`` subdirectory of the wiki source tree.

The permanent index page ``modules.rst`` uses ``toctree`` with ``:glob:`` to
automatically pick up every generated file — no need to regenerate the index.

Usage:
    python3 modules/generate_doc.py

Output directory: ../npf-docs/docs/source/modules/  (relative to NPF root).
"""

import os
import re
import shutil
import textwrap

SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))
NPF_ROOT = os.path.dirname(SCRIPT_DIR)
OUTPUT_DIR = os.path.join(NPF_ROOT, "..", "npf-docs", "docs", "source", "modules")


def parse_info(filepath):
    """Return the content of the %info section of an .npf file, or None."""
    in_info = False
    lines = []
    with open(filepath, "r") as f:
        for line in f:
            if line.startswith("%"):
                if line.strip().startswith("%info"):
                    in_info = True
                    continue
                elif in_info:
                    break  # next section starts
            elif in_info:
                lines.append(line.rstrip())
    return "\n".join(lines).strip() if lines else None


def is_deprecated(info_text):
    """Check whether the first few lines of %info contain a deprecation notice."""
    if not info_text:
        return False
    for line in info_text.splitlines()[:3]:
        if re.search(r"deprecated", line, re.IGNORECASE):
            return True
    return False


def indent(text, prefix="   "):
    """Indent every line of text with the given prefix."""
    return textwrap.indent(text, prefix)


def generate_module_rst(name, info):
    """Generate the RST content for a single module page."""
    title = name
    lines = []
    lines.append(f".. Auto-generated by modules/generate_doc.py — do not edit manually.")
    lines.append("")
    lines.append(title)
    lines.append("=" * len(title))
    lines.append("")
    if info:
        lines.append(".. code-block:: text")
        lines.append("")
        lines.append(indent(info))
        lines.append("")
    else:
        lines.append("*No description available.*")
        lines.append("")
    return "\n".join(lines) + "\n"


# Nouvelle fonction pour transformer les références modules en liens Sphinx
def linkify_info(info, module_names, current_name):
    if not info or not module_names:
        return info
    # Trie par longueur décroissante pour éviter les collisions partielles
    sorted_names = sorted(module_names - {current_name}, key=len, reverse=True)
    if not sorted_names:
        return info
    # Mot entier, insensible à la casse
    pattern = r'(?<![`\\w])(' + '|'.join(re.escape(n) for n in sorted_names) + r')(?![`\\w])'
    def repl(match):
        mod = match.group(1)
        # Respecte la casse d'origine dans le texte
        return f':doc:`{mod} <modules/{mod}>`'
    return re.sub(pattern, repl, info, flags=re.IGNORECASE)



def main():
    modules_dir = SCRIPT_DIR
    npf_files = sorted(
        f for f in os.listdir(modules_dir) if f.endswith(".npf")
    )

    output_dir = os.path.normpath(OUTPUT_DIR)

    # Première passe : construire la liste des modules valides (non dépréciés)
    module_names = set()
    module_infos = {}
    skipped = []
    for filename in npf_files:
        filepath = os.path.join(modules_dir, filename)
        info = parse_info(filepath)
        if is_deprecated(info):
            skipped.append(filename)
            continue
        name = filename.removesuffix(".npf")
        module_names.add(name)
        module_infos[name] = info

    # Clean previous generated files
    if os.path.isdir(output_dir):
        shutil.rmtree(output_dir)
    os.makedirs(output_dir, exist_ok=True)

    written = 0
    for name, info in module_infos.items():
        info_linked = linkify_info(info, module_names, name)
        rst = generate_module_rst(name, info_linked)
        out_file = os.path.join(output_dir, f"{name}.rst")
        with open(out_file, "w") as f:
            f.write(rst)
        written += 1

    print(f"Generated {written} files in {output_dir}")
    print(f"  {len(skipped)} deprecated modules skipped")
    if skipped:
        print(f"  Skipped: {', '.join(skipped)}")


if __name__ == "__main__":
    main()
